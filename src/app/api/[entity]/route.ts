// ============================================================
// API ROUTE HANDLERS - COLLECTION ROUTES - myTrimmy-prep
// Generated: 2026-01-14
// ============================================================
//
// DYNAMIC ROUTE: /api/[entity]
// Handles list (GET) and create (POST) operations for all entities.
//
// DEFENSIVE PATTERNS (Inversion Mental Model):
// - What could go wrong? → Request ID for tracing all errors
// - What would cause users to abandon? → Clear error messages
// - What would make debugging hard? → Structured logging
//
//
// SCALABILITY PATTERNS (Second-Order Mental Model):
// - What happens at 10x users? → Cache-Control headers reduce load
// - What cascades from slow APIs? → ETag for conditional requests
//
// ============================================================

import { NextRequest } from "next/server";
import { getUser as getAuthUser } from "@/lib/supabase/server";
import {
  type ApiResponse,
  type PaginatedResponse,
  apiSuccess,
  apiError,
} from "@/types/api";
import {
  badRequest,
  unauthorized,
  notFound,
  internalError,
  apiErrorToStatus,
} from "@/types/errors";
import {
  logger,
  withSpan,
  httpErrorsTotal,
} from "@/lib/observability";
import {
  validatePagination,
} from "@/lib/validation";

// ============================================================
// TYPES
// ============================================================

// Support both singular and plural entity names in URL paths
type EntityName = never;

interface RouteParams {
  params: Promise<{ entity: string }>;
}

// ============================================================
// DEFENSIVE: REQUEST HELPERS
// ============================================================

const MAX_BODY_SIZE = 1_048_576; // 1MB

const safeParseJson = async (
  request: NextRequest
): Promise<{ ok: true; data: unknown } | { ok: false; error: string }> => {
  try {
    const contentType = request.headers.get("content-type");
    if (!contentType?.includes("application/json")) {
      return { ok: false, error: "Content-Type must be application/json" };
    }

    const contentLength = request.headers.get("content-length");
    if (contentLength && parseInt(contentLength, 10) > MAX_BODY_SIZE) {
      return { ok: false, error: `Request body too large (max ${MAX_BODY_SIZE} bytes)` };
    }

    const body = await request.json();
    return { ok: true, data: body };
  } catch {
    return { ok: false, error: "Invalid JSON body" };
  }
};

// ============================================================
// ENTITY HANDLERS
// ============================================================


// ============================================================
// ROUTE HANDLERS
// ============================================================

/**
 * GET /api/[entity]
 * List entities with pagination and optional filters.
 */
export async function GET(
  request: NextRequest,
  { params }: RouteParams
): Promise<Response> {
  const { entity } = await params;

  switch (entity as EntityName) {
    default:
      const error = notFound(`Unknown entity: ${entity}`);
      return Response.json(apiError(error), { status: apiErrorToStatus(error) });
  }
}

/**
 * POST /api/[entity]
 * Create a new entity.
 */
export async function POST(
  request: NextRequest,
  { params }: RouteParams
): Promise<Response> {
  const { entity } = await params;

  switch (entity as EntityName) {
    default:
      const error = notFound(`Unknown entity: ${entity}`);
      return Response.json(apiError(error), { status: apiErrorToStatus(error) });
  }
}

// ============================================================
// GENERATED BY MENTAL MODELS SDLC
// ============================================================
